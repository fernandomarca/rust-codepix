// Code generated by Prisma Client Rust. DO NOT EDIT.

use prisma_client_rust::datamodel::parse_configuration;
use prisma_client_rust::prisma_models::InternalDataModelBuilder;
use prisma_client_rust::query::*;
use prisma_client_rust::query_core::{
    executor, schema_builder, BuildMode, QueryExecutor, QuerySchema,
};
use prisma_client_rust::DeleteResult;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
pub struct PrismaClient {
    executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
    query_schema: Arc<QuerySchema>,
}
impl PrismaClient {
    pub async fn new() -> Self {
        let datamodel_str = "generator client {\n  provider      = \"prisma-client-rust\"\n  output        = \"../src/infrastructure/prisma_db/db.rs\"\n  binaryTargets = [\"native\"]\n}\n\ngenerator erd {\n  provider = \"prisma-erd-generator\"\n  output   = \"./erd.svg\"\n}\n\ngenerator dbml {\n  provider   = \"prisma-dbml-generator\"\n  outputName = \"dev.dbml\"\n}\n\ngenerator docs {\n  provider = \"node node_modules/prisma-docs-generator\"\n}\n\ndatasource db {\n  provider = \"sqlite\"\n  url      = \"file:./dev.db\"\n}\n\nmodel AccountP {\n  id         String  @id @unique\n  owner_name String\n  bank_id    String\n  number     String\n  createdAt  String\n  updatedAt  String?\n\n  bank    BankP  @relation(fields: [bankId2], references: [id])\n  bankId2 String\n\n  PixKeys      PixKeyP[]\n  TransactionP TransactionP[]\n  @@map(\"account\")\n}\n\nmodel BankP {\n  id        String  @id @unique\n  name      String\n  code      String\n  createdAt String\n  updatedAt String?\n\n  Account AccountP[]\n\n  @@map(\"bank\")\n}\n\nmodel PixKeyP {\n  id   String @id @default(uuid())\n  kind String\n  key  String\n\n  createdAt String\n  updatedAt String?\n\n  Account    AccountP @relation(fields: [accountPId], references: [id])\n  accountPId String\n  status     String\n\n  TransactionP TransactionP[]\n  @@map(\"pixkey\")\n}\n\nmodel TransactionP {\n  id            String   @id\n  accountFrom   AccountP @relation(fields: [accountPId], references: [id])\n  accountPId    String\n  accountFromId String\n\n  amount Float\n\n  pixKeyTo   PixKeyP @relation(fields: [pixKeyPId], references: [id])\n  pixKeyPId  String\n  pixKeyIdTo String\n\n  status            String\n  description       String\n  cancelDescription String?\n\n  createdAt String\n  updatedAt String?\n\n  @@map(\"transaction\")\n}\n" ;
        let config = parse_configuration(datamodel_str).unwrap().subject;
        let source = config
            .datasources
            .first()
            .expect("Pleasy supply a datasource in your schema.prisma file");
        let url = if let Some(url) = source.load_shadow_database_url().unwrap() {
            url
        } else {
            source.load_url(|key| std::env::var(key).ok()).unwrap()
        };
        let (db_name, executor) = executor::load(&source, &[], &url).await.unwrap();
        let internal_model = InternalDataModelBuilder::new(&datamodel_str).build(db_name);
        let query_schema = Arc::new(schema_builder::build(
            internal_model,
            BuildMode::Modern,
            true,
            source.capabilities(),
            vec![],
            source.referential_integrity(),
        ));
        executor.primary_connector().get_connection().await.unwrap();
        Self {
            executor,
            query_schema,
        }
    }
    pub fn account_p(&self) -> AccountPActions {
        AccountPActions { client: &self }
    }
    pub fn bank_p(&self) -> BankPActions {
        BankPActions { client: &self }
    }
    pub fn pix_key_p(&self) -> PixKeyPActions {
        PixKeyPActions { client: &self }
    }
    pub fn transaction_p(&self) -> TransactionPActions {
        TransactionPActions { client: &self }
    }
}
fn account_p_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("owner_name"),
        Output::new("bank_id"),
        Output::new("number"),
        Output::new("createdAt"),
        Output::new("updatedAt"),
        Output::new("bankId2"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountPData {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "owner_name")]
    pub owner_name: String,
    #[serde(rename = "bank_id")]
    pub bank_id: String,
    #[serde(rename = "number")]
    pub number: String,
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[serde(rename = "updatedAt")]
    pub updated_at: Option<String>,
    #[serde(rename = "bank")]
    bank: Option<BankPData>,
    #[serde(rename = "bankId2")]
    pub bank_id_2: String,
    #[serde(rename = "PixKeys")]
    pix_keys: Option<Vec<PixKeyPData>>,
    #[serde(rename = "TransactionP")]
    transaction_p: Option<Vec<TransactionPData>>,
}
impl AccountPData {
    pub fn bank(&self) -> Result<&BankPData, String> {
        match &self.bank {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access bank but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
    pub fn pix_keys(&self) -> Result<&Vec<PixKeyPData>, String> {
        match &self.pix_keys {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access pix_keys but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
    pub fn transaction_p(&self) -> Result<&Vec<TransactionPData>, String> {
        match &self.transaction_p {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access transaction_p but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct AccountP {}
impl AccountP {
    pub fn id() -> AccountPIdField {
        AccountPIdField {}
    }
    pub fn owner_name() -> AccountPOwnerNameField {
        AccountPOwnerNameField {}
    }
    pub fn bank_id() -> AccountPBankIdField {
        AccountPBankIdField {}
    }
    pub fn number() -> AccountPNumberField {
        AccountPNumberField {}
    }
    pub fn created_at() -> AccountPCreatedAtField {
        AccountPCreatedAtField {}
    }
    pub fn updated_at() -> AccountPUpdatedAtField {
        AccountPUpdatedAtField {}
    }
    pub fn bank() -> AccountPBankField {
        AccountPBankField {}
    }
    pub fn bank_id_2() -> AccountPBankId2Field {
        AccountPBankId2Field {}
    }
    pub fn pix_keys() -> AccountPPixKeysField {
        AccountPPixKeysField {}
    }
    pub fn transaction_p() -> AccountPTransactionPField {
        AccountPTransactionPField {}
    }
    pub fn not(params: Vec<AccountPWhereParam>) -> AccountPWhereParam {
        AccountPWhereParam::Not(params)
    }
    pub fn or(params: Vec<AccountPWhereParam>) -> AccountPWhereParam {
        AccountPWhereParam::Or(params)
    }
    pub fn and(params: Vec<AccountPWhereParam>) -> AccountPWhereParam {
        AccountPWhereParam::And(params)
    }
}
pub struct AccountPIdField {}
pub struct AccountPSetId(String);
impl From<AccountPSetId> for AccountPSetParam {
    fn from(value: AccountPSetId) -> Self {
        Self::Id(value.0)
    }
}
impl AccountPIdField {
    pub fn contains(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::IdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::IdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::IdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::IdEquals(value)
    }
    pub fn set<T: From<AccountPSetId>>(&self, value: String) -> T {
        AccountPSetId(value).into()
    }
}
pub struct AccountPOwnerNameField {}
pub struct AccountPSetOwnerName(String);
impl From<AccountPSetOwnerName> for AccountPSetParam {
    fn from(value: AccountPSetOwnerName) -> Self {
        Self::OwnerName(value.0)
    }
}
impl AccountPOwnerNameField {
    pub fn contains(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::OwnerNameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::OwnerNameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::OwnerNameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::OwnerNameEquals(value)
    }
    pub fn set<T: From<AccountPSetOwnerName>>(&self, value: String) -> T {
        AccountPSetOwnerName(value).into()
    }
}
pub struct AccountPBankIdField {}
pub struct AccountPSetBankId(String);
impl From<AccountPSetBankId> for AccountPSetParam {
    fn from(value: AccountPSetBankId) -> Self {
        Self::BankId(value.0)
    }
}
impl AccountPBankIdField {
    pub fn contains(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::BankIdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::BankIdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::BankIdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::BankIdEquals(value)
    }
    pub fn set<T: From<AccountPSetBankId>>(&self, value: String) -> T {
        AccountPSetBankId(value).into()
    }
}
pub struct AccountPNumberField {}
pub struct AccountPSetNumber(String);
impl From<AccountPSetNumber> for AccountPSetParam {
    fn from(value: AccountPSetNumber) -> Self {
        Self::Number(value.0)
    }
}
impl AccountPNumberField {
    pub fn contains(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::NumberContains(value)
    }
    pub fn has_prefix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::NumberHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::NumberHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::NumberEquals(value)
    }
    pub fn set<T: From<AccountPSetNumber>>(&self, value: String) -> T {
        AccountPSetNumber(value).into()
    }
}
pub struct AccountPCreatedAtField {}
pub struct AccountPSetCreatedAt(String);
impl From<AccountPSetCreatedAt> for AccountPSetParam {
    fn from(value: AccountPSetCreatedAt) -> Self {
        Self::CreatedAt(value.0)
    }
}
impl AccountPCreatedAtField {
    pub fn contains(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::CreatedAtContains(value)
    }
    pub fn has_prefix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::CreatedAtHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::CreatedAtHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::CreatedAtEquals(value)
    }
    pub fn set<T: From<AccountPSetCreatedAt>>(&self, value: String) -> T {
        AccountPSetCreatedAt(value).into()
    }
}
pub struct AccountPUpdatedAtField {}
pub struct AccountPSetUpdatedAt(String);
impl From<AccountPSetUpdatedAt> for AccountPSetParam {
    fn from(value: AccountPSetUpdatedAt) -> Self {
        Self::UpdatedAt(value.0)
    }
}
impl AccountPUpdatedAtField {
    pub fn contains(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::UpdatedAtContains(value)
    }
    pub fn has_prefix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::UpdatedAtHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::UpdatedAtHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::UpdatedAtEquals(value)
    }
    pub fn set<T: From<AccountPSetUpdatedAt>>(&self, value: String) -> T {
        AccountPSetUpdatedAt(value).into()
    }
}
pub struct AccountPBankField {}
pub struct AccountPSetBank(BankPWhereParam);
impl From<AccountPSetBank> for AccountPSetParam {
    fn from(value: AccountPSetBank) -> Self {
        Self::Bank(value.0)
    }
}
impl AccountPBankField {
    pub fn is(&self, value: Vec<BankPWhereParam>) -> AccountPWhereParam {
        AccountPWhereParam::BankIs(value)
    }
    pub fn link<T: From<AccountPSetBank>>(&self, value: BankPWhereParam) -> T {
        AccountPSetBank(value).into()
    }
    pub fn fetch(&self) -> AccountPWith {
        AccountPWithParam::Bank.into()
    }
}
pub struct AccountPBankId2Field {}
pub struct AccountPSetBankId2(String);
impl From<AccountPSetBankId2> for AccountPSetParam {
    fn from(value: AccountPSetBankId2) -> Self {
        Self::BankId2(value.0)
    }
}
impl AccountPBankId2Field {
    pub fn contains(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::BankId2Contains(value)
    }
    pub fn has_prefix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::BankId2HasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::BankId2HasSuffix(value)
    }
    pub fn equals(&self, value: String) -> AccountPWhereParam {
        AccountPWhereParam::BankId2Equals(value)
    }
    pub fn set<T: From<AccountPSetBankId2>>(&self, value: String) -> T {
        AccountPSetBankId2(value).into()
    }
}
pub struct AccountPPixKeysField {}
pub struct AccountPSetPixKeys(Vec<PixKeyPWhereParam>);
impl From<AccountPSetPixKeys> for AccountPSetParam {
    fn from(value: AccountPSetPixKeys) -> Self {
        Self::PixKeys(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl AccountPPixKeysField {
    pub fn some(&self, value: Vec<PixKeyPWhereParam>) -> AccountPWhereParam {
        AccountPWhereParam::PixKeysSome(value)
    }
    pub fn every(&self, value: Vec<PixKeyPWhereParam>) -> AccountPWhereParam {
        AccountPWhereParam::PixKeysEvery(value)
    }
    pub fn link<T: From<AccountPSetPixKeys>>(&self, value: Vec<PixKeyPWhereParam>) -> T {
        AccountPSetPixKeys(value).into()
    }
    pub fn fetch(&self, params: Vec<PixKeyPWhereParam>) -> AccountPWith {
        AccountPWithParam::PixKeys(params).into()
    }
}
pub struct AccountPTransactionPField {}
pub struct AccountPSetTransactionP(Vec<TransactionPWhereParam>);
impl From<AccountPSetTransactionP> for AccountPSetParam {
    fn from(value: AccountPSetTransactionP) -> Self {
        Self::TransactionP(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl AccountPTransactionPField {
    pub fn some(&self, value: Vec<TransactionPWhereParam>) -> AccountPWhereParam {
        AccountPWhereParam::TransactionPSome(value)
    }
    pub fn every(&self, value: Vec<TransactionPWhereParam>) -> AccountPWhereParam {
        AccountPWhereParam::TransactionPEvery(value)
    }
    pub fn link<T: From<AccountPSetTransactionP>>(&self, value: Vec<TransactionPWhereParam>) -> T {
        AccountPSetTransactionP(value).into()
    }
    pub fn fetch(&self, params: Vec<TransactionPWhereParam>) -> AccountPWith {
        AccountPWithParam::TransactionP(params).into()
    }
}
pub struct AccountPActions<'a> {
    client: &'a PrismaClient,
}
pub enum AccountPWhereParam {
    IdContains(String),
    IdHasPrefix(String),
    IdHasSuffix(String),
    IdEquals(String),
    OwnerNameContains(String),
    OwnerNameHasPrefix(String),
    OwnerNameHasSuffix(String),
    OwnerNameEquals(String),
    BankIdContains(String),
    BankIdHasPrefix(String),
    BankIdHasSuffix(String),
    BankIdEquals(String),
    NumberContains(String),
    NumberHasPrefix(String),
    NumberHasSuffix(String),
    NumberEquals(String),
    CreatedAtContains(String),
    CreatedAtHasPrefix(String),
    CreatedAtHasSuffix(String),
    CreatedAtEquals(String),
    UpdatedAtContains(String),
    UpdatedAtHasPrefix(String),
    UpdatedAtHasSuffix(String),
    UpdatedAtEquals(String),
    BankIs(Vec<BankPWhereParam>),
    BankId2Contains(String),
    BankId2HasPrefix(String),
    BankId2HasSuffix(String),
    BankId2Equals(String),
    PixKeysSome(Vec<PixKeyPWhereParam>),
    PixKeysEvery(Vec<PixKeyPWhereParam>),
    TransactionPSome(Vec<TransactionPWhereParam>),
    TransactionPEvery(Vec<TransactionPWhereParam>),
    Not(Vec<AccountPWhereParam>),
    Or(Vec<AccountPWhereParam>),
    And(Vec<AccountPWhereParam>),
}
impl AccountPWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdContains(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasPrefix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasSuffix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::OwnerNameContains(value) => Field {
                name: "owner_name".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::OwnerNameHasPrefix(value) => Field {
                name: "owner_name".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::OwnerNameHasSuffix(value) => Field {
                name: "owner_name".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::OwnerNameEquals(value) => Field {
                name: "owner_name".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::BankIdContains(value) => Field {
                name: "bank_id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::BankIdHasPrefix(value) => Field {
                name: "bank_id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::BankIdHasSuffix(value) => Field {
                name: "bank_id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::BankIdEquals(value) => Field {
                name: "bank_id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NumberContains(value) => Field {
                name: "number".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NumberHasPrefix(value) => Field {
                name: "number".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NumberHasSuffix(value) => Field {
                name: "number".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NumberEquals(value) => Field {
                name: "number".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtContains(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtHasPrefix(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtHasSuffix(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtEquals(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtContains(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtHasPrefix(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtHasSuffix(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtEquals(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::BankIs(value) => Field {
                name: "bank".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::BankId2Contains(value) => Field {
                name: "bankId2".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::BankId2HasPrefix(value) => Field {
                name: "bankId2".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::BankId2HasSuffix(value) => Field {
                name: "bankId2".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::BankId2Equals(value) => Field {
                name: "bankId2".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeysSome(value) => Field {
                name: "PixKeys".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeysEvery(value) => Field {
                name: "PixKeys".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TransactionPSome(value) => Field {
                name: "TransactionP".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TransactionPEvery(value) => Field {
                name: "TransactionP".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct AccountPWith {
    pub param: AccountPWithParam,
}
pub enum AccountPWithParam {
    Bank,
    PixKeys(Vec<PixKeyPWhereParam>),
    TransactionP(Vec<TransactionPWhereParam>),
}
impl From<AccountPWithParam> for AccountPWith {
    fn from(param: AccountPWithParam) -> Self {
        Self { param }
    }
}
impl AccountPWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Bank => Output {
                name: "bank".into(),
                outputs: bank_p_outputs(),
                ..Default::default()
            },
            Self::PixKeys(where_params) => Output {
                name: "PixKeys".into(),
                outputs: pix_key_p_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
            Self::TransactionP(where_params) => Output {
                name: "TransactionP".into(),
                outputs: transaction_p_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
        }
    }
}
pub enum AccountPSetParam {
    Id(String),
    OwnerName(String),
    BankId(String),
    Number(String),
    CreatedAt(String),
    UpdatedAt(String),
    Bank(BankPWhereParam),
    BankId2(String),
    PixKeys(Vec<PixKeyPWhereParam>),
    TransactionP(Vec<TransactionPWhereParam>),
}
impl AccountPSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::OwnerName(value) => Field {
                name: "owner_name".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::BankId(value) => Field {
                name: "bank_id".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Number(value) => Field {
                name: "number".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::CreatedAt(value) => Field {
                name: "createdAt".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::UpdatedAt(value) => Field {
                name: "updatedAt".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Bank(where_param) => Field {
                name: "bank".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::BankId2(value) => Field {
                name: "bankId2".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::PixKeys(where_params) => Field {
                name: "PixKeys".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TransactionP(where_params) => Field {
                name: "TransactionP".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub struct AccountPFindMany<'a> {
    query: Query<'a>,
}
impl<'a> AccountPFindMany<'a> {
    pub async fn exec(self) -> Vec<AccountPData> {
        self.query.perform().await
    }
    pub fn delete(self) -> AccountPDelete<'a> {
        AccountPDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "AccountP".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<AccountPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct AccountPFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> AccountPFindFirst<'a> {
    pub async fn exec(self) -> AccountPData {
        self.query.perform().await
    }
    pub fn with(mut self, fetches: Vec<AccountPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct AccountPFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> AccountPFindUnique<'a> {
    pub async fn exec(self) -> AccountPData {
        self.query.perform().await
    }
    pub fn delete(self) -> AccountPDelete<'a> {
        AccountPDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "AccountP".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<AccountPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct AccountPCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> AccountPCreateOne<'a> {
    pub async fn exec(self) -> AccountPData {
        self.query.perform().await
    }
}
pub struct AccountPDelete<'a> {
    query: Query<'a>,
}
impl<'a> AccountPDelete<'a> {
    pub async fn exec(self) -> isize {
        let result: DeleteResult = self.query.perform().await;
        result.count
    }
}
impl<'a> AccountPActions<'a> {
    pub fn find_unique(&self, param: AccountPWhereParam) -> AccountPFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "AccountP".into(),
            outputs: account_p_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        AccountPFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<AccountPWhereParam>) -> AccountPFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "AccountP".into(),
            outputs: account_p_outputs(),
            inputs,
        };
        AccountPFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<AccountPWhereParam>) -> AccountPFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "AccountP".into(),
            outputs: account_p_outputs(),
            inputs,
        };
        AccountPFindMany { query }
    }
    pub fn create_one(
        &self,
        id: AccountPSetId,
        owner_name: AccountPSetOwnerName,
        bank_id: AccountPSetBankId,
        number: AccountPSetNumber,
        created_at: AccountPSetCreatedAt,
        bank: AccountPSetBank,
        params: Vec<AccountPSetParam>,
    ) -> AccountPCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(AccountPSetParam::from(id).field());
        input_fields.push(AccountPSetParam::from(owner_name).field());
        input_fields.push(AccountPSetParam::from(bank_id).field());
        input_fields.push(AccountPSetParam::from(number).field());
        input_fields.push(AccountPSetParam::from(created_at).field());
        input_fields.push(AccountPSetParam::from(bank).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "AccountP".into(),
            outputs: account_p_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        AccountPCreateOne { query }
    }
}
fn bank_p_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("name"),
        Output::new("code"),
        Output::new("createdAt"),
        Output::new("updatedAt"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BankPData {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "code")]
    pub code: String,
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[serde(rename = "updatedAt")]
    pub updated_at: Option<String>,
    #[serde(rename = "Account")]
    account: Option<Vec<AccountPData>>,
}
impl BankPData {
    pub fn account(&self) -> Result<&Vec<AccountPData>, String> {
        match &self.account {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access account but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct BankP {}
impl BankP {
    pub fn id() -> BankPIdField {
        BankPIdField {}
    }
    pub fn name() -> BankPNameField {
        BankPNameField {}
    }
    pub fn code() -> BankPCodeField {
        BankPCodeField {}
    }
    pub fn created_at() -> BankPCreatedAtField {
        BankPCreatedAtField {}
    }
    pub fn updated_at() -> BankPUpdatedAtField {
        BankPUpdatedAtField {}
    }
    pub fn account() -> BankPAccountField {
        BankPAccountField {}
    }
    pub fn not(params: Vec<BankPWhereParam>) -> BankPWhereParam {
        BankPWhereParam::Not(params)
    }
    pub fn or(params: Vec<BankPWhereParam>) -> BankPWhereParam {
        BankPWhereParam::Or(params)
    }
    pub fn and(params: Vec<BankPWhereParam>) -> BankPWhereParam {
        BankPWhereParam::And(params)
    }
}
pub struct BankPIdField {}
pub struct BankPSetId(String);
impl From<BankPSetId> for BankPSetParam {
    fn from(value: BankPSetId) -> Self {
        Self::Id(value.0)
    }
}
impl BankPIdField {
    pub fn contains(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::IdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::IdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::IdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::IdEquals(value)
    }
    pub fn set<T: From<BankPSetId>>(&self, value: String) -> T {
        BankPSetId(value).into()
    }
}
pub struct BankPNameField {}
pub struct BankPSetName(String);
impl From<BankPSetName> for BankPSetParam {
    fn from(value: BankPSetName) -> Self {
        Self::Name(value.0)
    }
}
impl BankPNameField {
    pub fn contains(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::NameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::NameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::NameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::NameEquals(value)
    }
    pub fn set<T: From<BankPSetName>>(&self, value: String) -> T {
        BankPSetName(value).into()
    }
}
pub struct BankPCodeField {}
pub struct BankPSetCode(String);
impl From<BankPSetCode> for BankPSetParam {
    fn from(value: BankPSetCode) -> Self {
        Self::Code(value.0)
    }
}
impl BankPCodeField {
    pub fn contains(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::CodeContains(value)
    }
    pub fn has_prefix(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::CodeHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::CodeHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::CodeEquals(value)
    }
    pub fn set<T: From<BankPSetCode>>(&self, value: String) -> T {
        BankPSetCode(value).into()
    }
}
pub struct BankPCreatedAtField {}
pub struct BankPSetCreatedAt(String);
impl From<BankPSetCreatedAt> for BankPSetParam {
    fn from(value: BankPSetCreatedAt) -> Self {
        Self::CreatedAt(value.0)
    }
}
impl BankPCreatedAtField {
    pub fn contains(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::CreatedAtContains(value)
    }
    pub fn has_prefix(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::CreatedAtHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::CreatedAtHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::CreatedAtEquals(value)
    }
    pub fn set<T: From<BankPSetCreatedAt>>(&self, value: String) -> T {
        BankPSetCreatedAt(value).into()
    }
}
pub struct BankPUpdatedAtField {}
pub struct BankPSetUpdatedAt(String);
impl From<BankPSetUpdatedAt> for BankPSetParam {
    fn from(value: BankPSetUpdatedAt) -> Self {
        Self::UpdatedAt(value.0)
    }
}
impl BankPUpdatedAtField {
    pub fn contains(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::UpdatedAtContains(value)
    }
    pub fn has_prefix(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::UpdatedAtHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::UpdatedAtHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> BankPWhereParam {
        BankPWhereParam::UpdatedAtEquals(value)
    }
    pub fn set<T: From<BankPSetUpdatedAt>>(&self, value: String) -> T {
        BankPSetUpdatedAt(value).into()
    }
}
pub struct BankPAccountField {}
pub struct BankPSetAccount(Vec<AccountPWhereParam>);
impl From<BankPSetAccount> for BankPSetParam {
    fn from(value: BankPSetAccount) -> Self {
        Self::Account(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl BankPAccountField {
    pub fn some(&self, value: Vec<AccountPWhereParam>) -> BankPWhereParam {
        BankPWhereParam::AccountSome(value)
    }
    pub fn every(&self, value: Vec<AccountPWhereParam>) -> BankPWhereParam {
        BankPWhereParam::AccountEvery(value)
    }
    pub fn link<T: From<BankPSetAccount>>(&self, value: Vec<AccountPWhereParam>) -> T {
        BankPSetAccount(value).into()
    }
    pub fn fetch(&self, params: Vec<AccountPWhereParam>) -> BankPWith {
        BankPWithParam::Account(params).into()
    }
}
pub struct BankPActions<'a> {
    client: &'a PrismaClient,
}
pub enum BankPWhereParam {
    IdContains(String),
    IdHasPrefix(String),
    IdHasSuffix(String),
    IdEquals(String),
    NameContains(String),
    NameHasPrefix(String),
    NameHasSuffix(String),
    NameEquals(String),
    CodeContains(String),
    CodeHasPrefix(String),
    CodeHasSuffix(String),
    CodeEquals(String),
    CreatedAtContains(String),
    CreatedAtHasPrefix(String),
    CreatedAtHasSuffix(String),
    CreatedAtEquals(String),
    UpdatedAtContains(String),
    UpdatedAtHasPrefix(String),
    UpdatedAtHasSuffix(String),
    UpdatedAtEquals(String),
    AccountSome(Vec<AccountPWhereParam>),
    AccountEvery(Vec<AccountPWhereParam>),
    Not(Vec<BankPWhereParam>),
    Or(Vec<BankPWhereParam>),
    And(Vec<BankPWhereParam>),
}
impl BankPWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdContains(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasPrefix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasSuffix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameContains(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasPrefix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameHasSuffix(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::NameEquals(value) => Field {
                name: "name".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CodeContains(value) => Field {
                name: "code".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CodeHasPrefix(value) => Field {
                name: "code".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CodeHasSuffix(value) => Field {
                name: "code".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CodeEquals(value) => Field {
                name: "code".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtContains(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtHasPrefix(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtHasSuffix(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtEquals(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtContains(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtHasPrefix(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtHasSuffix(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtEquals(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountSome(value) => Field {
                name: "Account".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountEvery(value) => Field {
                name: "Account".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct BankPWith {
    pub param: BankPWithParam,
}
pub enum BankPWithParam {
    Account(Vec<AccountPWhereParam>),
}
impl From<BankPWithParam> for BankPWith {
    fn from(param: BankPWithParam) -> Self {
        Self { param }
    }
}
impl BankPWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Account(where_params) => Output {
                name: "Account".into(),
                outputs: account_p_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
        }
    }
}
pub enum BankPSetParam {
    Id(String),
    Name(String),
    Code(String),
    CreatedAt(String),
    UpdatedAt(String),
    Account(Vec<AccountPWhereParam>),
}
impl BankPSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Name(value) => Field {
                name: "name".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Code(value) => Field {
                name: "code".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::CreatedAt(value) => Field {
                name: "createdAt".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::UpdatedAt(value) => Field {
                name: "updatedAt".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Account(where_params) => Field {
                name: "Account".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub struct BankPFindMany<'a> {
    query: Query<'a>,
}
impl<'a> BankPFindMany<'a> {
    pub async fn exec(self) -> Vec<BankPData> {
        self.query.perform().await
    }
    pub fn delete(self) -> BankPDelete<'a> {
        BankPDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "BankP".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<BankPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct BankPFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> BankPFindFirst<'a> {
    pub async fn exec(self) -> BankPData {
        self.query.perform().await
    }
    pub fn with(mut self, fetches: Vec<BankPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct BankPFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> BankPFindUnique<'a> {
    pub async fn exec(self) -> BankPData {
        self.query.perform().await
    }
    pub fn delete(self) -> BankPDelete<'a> {
        BankPDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "BankP".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<BankPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct BankPCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> BankPCreateOne<'a> {
    pub async fn exec(self) -> BankPData {
        self.query.perform().await
    }
}
pub struct BankPDelete<'a> {
    query: Query<'a>,
}
impl<'a> BankPDelete<'a> {
    pub async fn exec(self) -> isize {
        let result: DeleteResult = self.query.perform().await;
        result.count
    }
}
impl<'a> BankPActions<'a> {
    pub fn find_unique(&self, param: BankPWhereParam) -> BankPFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "BankP".into(),
            outputs: bank_p_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        BankPFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<BankPWhereParam>) -> BankPFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "BankP".into(),
            outputs: bank_p_outputs(),
            inputs,
        };
        BankPFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<BankPWhereParam>) -> BankPFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "BankP".into(),
            outputs: bank_p_outputs(),
            inputs,
        };
        BankPFindMany { query }
    }
    pub fn create_one(
        &self,
        id: BankPSetId,
        name: BankPSetName,
        code: BankPSetCode,
        created_at: BankPSetCreatedAt,
        params: Vec<BankPSetParam>,
    ) -> BankPCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(BankPSetParam::from(id).field());
        input_fields.push(BankPSetParam::from(name).field());
        input_fields.push(BankPSetParam::from(code).field());
        input_fields.push(BankPSetParam::from(created_at).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "BankP".into(),
            outputs: bank_p_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        BankPCreateOne { query }
    }
}
fn pix_key_p_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("kind"),
        Output::new("key"),
        Output::new("createdAt"),
        Output::new("updatedAt"),
        Output::new("accountPId"),
        Output::new("status"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PixKeyPData {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "kind")]
    pub kind: String,
    #[serde(rename = "key")]
    pub key: String,
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[serde(rename = "updatedAt")]
    pub updated_at: Option<String>,
    #[serde(rename = "Account")]
    account: Option<AccountPData>,
    #[serde(rename = "accountPId")]
    pub account_p_id: String,
    #[serde(rename = "status")]
    pub status: String,
    #[serde(rename = "TransactionP")]
    transaction_p: Option<Vec<TransactionPData>>,
}
impl PixKeyPData {
    pub fn account(&self) -> Result<&AccountPData, String> {
        match &self.account {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access account but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
    pub fn transaction_p(&self) -> Result<&Vec<TransactionPData>, String> {
        match &self.transaction_p {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access transaction_p but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct PixKeyP {}
impl PixKeyP {
    pub fn id() -> PixKeyPIdField {
        PixKeyPIdField {}
    }
    pub fn kind() -> PixKeyPKindField {
        PixKeyPKindField {}
    }
    pub fn key() -> PixKeyPKeyField {
        PixKeyPKeyField {}
    }
    pub fn created_at() -> PixKeyPCreatedAtField {
        PixKeyPCreatedAtField {}
    }
    pub fn updated_at() -> PixKeyPUpdatedAtField {
        PixKeyPUpdatedAtField {}
    }
    pub fn account() -> PixKeyPAccountField {
        PixKeyPAccountField {}
    }
    pub fn account_p_id() -> PixKeyPAccountPIdField {
        PixKeyPAccountPIdField {}
    }
    pub fn status() -> PixKeyPStatusField {
        PixKeyPStatusField {}
    }
    pub fn transaction_p() -> PixKeyPTransactionPField {
        PixKeyPTransactionPField {}
    }
    pub fn not(params: Vec<PixKeyPWhereParam>) -> PixKeyPWhereParam {
        PixKeyPWhereParam::Not(params)
    }
    pub fn or(params: Vec<PixKeyPWhereParam>) -> PixKeyPWhereParam {
        PixKeyPWhereParam::Or(params)
    }
    pub fn and(params: Vec<PixKeyPWhereParam>) -> PixKeyPWhereParam {
        PixKeyPWhereParam::And(params)
    }
}
pub struct PixKeyPIdField {}
pub struct PixKeyPSetId(String);
impl From<PixKeyPSetId> for PixKeyPSetParam {
    fn from(value: PixKeyPSetId) -> Self {
        Self::Id(value.0)
    }
}
impl PixKeyPIdField {
    pub fn contains(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::IdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::IdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::IdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::IdEquals(value)
    }
    pub fn set<T: From<PixKeyPSetId>>(&self, value: String) -> T {
        PixKeyPSetId(value).into()
    }
}
pub struct PixKeyPKindField {}
pub struct PixKeyPSetKind(String);
impl From<PixKeyPSetKind> for PixKeyPSetParam {
    fn from(value: PixKeyPSetKind) -> Self {
        Self::Kind(value.0)
    }
}
impl PixKeyPKindField {
    pub fn contains(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::KindContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::KindHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::KindHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::KindEquals(value)
    }
    pub fn set<T: From<PixKeyPSetKind>>(&self, value: String) -> T {
        PixKeyPSetKind(value).into()
    }
}
pub struct PixKeyPKeyField {}
pub struct PixKeyPSetKey(String);
impl From<PixKeyPSetKey> for PixKeyPSetParam {
    fn from(value: PixKeyPSetKey) -> Self {
        Self::Key(value.0)
    }
}
impl PixKeyPKeyField {
    pub fn contains(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::KeyContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::KeyHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::KeyHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::KeyEquals(value)
    }
    pub fn set<T: From<PixKeyPSetKey>>(&self, value: String) -> T {
        PixKeyPSetKey(value).into()
    }
}
pub struct PixKeyPCreatedAtField {}
pub struct PixKeyPSetCreatedAt(String);
impl From<PixKeyPSetCreatedAt> for PixKeyPSetParam {
    fn from(value: PixKeyPSetCreatedAt) -> Self {
        Self::CreatedAt(value.0)
    }
}
impl PixKeyPCreatedAtField {
    pub fn contains(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::CreatedAtContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::CreatedAtHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::CreatedAtHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::CreatedAtEquals(value)
    }
    pub fn set<T: From<PixKeyPSetCreatedAt>>(&self, value: String) -> T {
        PixKeyPSetCreatedAt(value).into()
    }
}
pub struct PixKeyPUpdatedAtField {}
pub struct PixKeyPSetUpdatedAt(String);
impl From<PixKeyPSetUpdatedAt> for PixKeyPSetParam {
    fn from(value: PixKeyPSetUpdatedAt) -> Self {
        Self::UpdatedAt(value.0)
    }
}
impl PixKeyPUpdatedAtField {
    pub fn contains(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::UpdatedAtContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::UpdatedAtHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::UpdatedAtHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::UpdatedAtEquals(value)
    }
    pub fn set<T: From<PixKeyPSetUpdatedAt>>(&self, value: String) -> T {
        PixKeyPSetUpdatedAt(value).into()
    }
}
pub struct PixKeyPAccountField {}
pub struct PixKeyPSetAccount(AccountPWhereParam);
impl From<PixKeyPSetAccount> for PixKeyPSetParam {
    fn from(value: PixKeyPSetAccount) -> Self {
        Self::Account(value.0)
    }
}
impl PixKeyPAccountField {
    pub fn is(&self, value: Vec<AccountPWhereParam>) -> PixKeyPWhereParam {
        PixKeyPWhereParam::AccountIs(value)
    }
    pub fn link<T: From<PixKeyPSetAccount>>(&self, value: AccountPWhereParam) -> T {
        PixKeyPSetAccount(value).into()
    }
    pub fn fetch(&self) -> PixKeyPWith {
        PixKeyPWithParam::Account.into()
    }
}
pub struct PixKeyPAccountPIdField {}
pub struct PixKeyPSetAccountPId(String);
impl From<PixKeyPSetAccountPId> for PixKeyPSetParam {
    fn from(value: PixKeyPSetAccountPId) -> Self {
        Self::AccountPId(value.0)
    }
}
impl PixKeyPAccountPIdField {
    pub fn contains(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::AccountPIdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::AccountPIdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::AccountPIdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::AccountPIdEquals(value)
    }
    pub fn set<T: From<PixKeyPSetAccountPId>>(&self, value: String) -> T {
        PixKeyPSetAccountPId(value).into()
    }
}
pub struct PixKeyPStatusField {}
pub struct PixKeyPSetStatus(String);
impl From<PixKeyPSetStatus> for PixKeyPSetParam {
    fn from(value: PixKeyPSetStatus) -> Self {
        Self::Status(value.0)
    }
}
impl PixKeyPStatusField {
    pub fn contains(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::StatusContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::StatusHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::StatusHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PixKeyPWhereParam {
        PixKeyPWhereParam::StatusEquals(value)
    }
    pub fn set<T: From<PixKeyPSetStatus>>(&self, value: String) -> T {
        PixKeyPSetStatus(value).into()
    }
}
pub struct PixKeyPTransactionPField {}
pub struct PixKeyPSetTransactionP(Vec<TransactionPWhereParam>);
impl From<PixKeyPSetTransactionP> for PixKeyPSetParam {
    fn from(value: PixKeyPSetTransactionP) -> Self {
        Self::TransactionP(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl PixKeyPTransactionPField {
    pub fn some(&self, value: Vec<TransactionPWhereParam>) -> PixKeyPWhereParam {
        PixKeyPWhereParam::TransactionPSome(value)
    }
    pub fn every(&self, value: Vec<TransactionPWhereParam>) -> PixKeyPWhereParam {
        PixKeyPWhereParam::TransactionPEvery(value)
    }
    pub fn link<T: From<PixKeyPSetTransactionP>>(&self, value: Vec<TransactionPWhereParam>) -> T {
        PixKeyPSetTransactionP(value).into()
    }
    pub fn fetch(&self, params: Vec<TransactionPWhereParam>) -> PixKeyPWith {
        PixKeyPWithParam::TransactionP(params).into()
    }
}
pub struct PixKeyPActions<'a> {
    client: &'a PrismaClient,
}
pub enum PixKeyPWhereParam {
    IdContains(String),
    IdHasPrefix(String),
    IdHasSuffix(String),
    IdEquals(String),
    KindContains(String),
    KindHasPrefix(String),
    KindHasSuffix(String),
    KindEquals(String),
    KeyContains(String),
    KeyHasPrefix(String),
    KeyHasSuffix(String),
    KeyEquals(String),
    CreatedAtContains(String),
    CreatedAtHasPrefix(String),
    CreatedAtHasSuffix(String),
    CreatedAtEquals(String),
    UpdatedAtContains(String),
    UpdatedAtHasPrefix(String),
    UpdatedAtHasSuffix(String),
    UpdatedAtEquals(String),
    AccountIs(Vec<AccountPWhereParam>),
    AccountPIdContains(String),
    AccountPIdHasPrefix(String),
    AccountPIdHasSuffix(String),
    AccountPIdEquals(String),
    StatusContains(String),
    StatusHasPrefix(String),
    StatusHasSuffix(String),
    StatusEquals(String),
    TransactionPSome(Vec<TransactionPWhereParam>),
    TransactionPEvery(Vec<TransactionPWhereParam>),
    Not(Vec<PixKeyPWhereParam>),
    Or(Vec<PixKeyPWhereParam>),
    And(Vec<PixKeyPWhereParam>),
}
impl PixKeyPWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdContains(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasPrefix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasSuffix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::KindContains(value) => Field {
                name: "kind".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::KindHasPrefix(value) => Field {
                name: "kind".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::KindHasSuffix(value) => Field {
                name: "kind".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::KindEquals(value) => Field {
                name: "kind".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::KeyContains(value) => Field {
                name: "key".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::KeyHasPrefix(value) => Field {
                name: "key".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::KeyHasSuffix(value) => Field {
                name: "key".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::KeyEquals(value) => Field {
                name: "key".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtContains(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtHasPrefix(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtHasSuffix(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtEquals(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtContains(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtHasPrefix(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtHasSuffix(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtEquals(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountIs(value) => Field {
                name: "Account".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountPIdContains(value) => Field {
                name: "accountPId".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountPIdHasPrefix(value) => Field {
                name: "accountPId".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountPIdHasSuffix(value) => Field {
                name: "accountPId".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountPIdEquals(value) => Field {
                name: "accountPId".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusContains(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusHasPrefix(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusHasSuffix(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusEquals(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TransactionPSome(value) => Field {
                name: "TransactionP".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::TransactionPEvery(value) => Field {
                name: "TransactionP".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct PixKeyPWith {
    pub param: PixKeyPWithParam,
}
pub enum PixKeyPWithParam {
    Account,
    TransactionP(Vec<TransactionPWhereParam>),
}
impl From<PixKeyPWithParam> for PixKeyPWith {
    fn from(param: PixKeyPWithParam) -> Self {
        Self { param }
    }
}
impl PixKeyPWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Account => Output {
                name: "Account".into(),
                outputs: account_p_outputs(),
                ..Default::default()
            },
            Self::TransactionP(where_params) => Output {
                name: "TransactionP".into(),
                outputs: transaction_p_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
        }
    }
}
pub enum PixKeyPSetParam {
    Id(String),
    Kind(String),
    Key(String),
    CreatedAt(String),
    UpdatedAt(String),
    Account(AccountPWhereParam),
    AccountPId(String),
    Status(String),
    TransactionP(Vec<TransactionPWhereParam>),
}
impl PixKeyPSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Kind(value) => Field {
                name: "kind".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Key(value) => Field {
                name: "key".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::CreatedAt(value) => Field {
                name: "createdAt".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::UpdatedAt(value) => Field {
                name: "updatedAt".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Account(where_param) => Field {
                name: "Account".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountPId(value) => Field {
                name: "accountPId".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Status(value) => Field {
                name: "status".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::TransactionP(where_params) => Field {
                name: "TransactionP".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub struct PixKeyPFindMany<'a> {
    query: Query<'a>,
}
impl<'a> PixKeyPFindMany<'a> {
    pub async fn exec(self) -> Vec<PixKeyPData> {
        self.query.perform().await
    }
    pub fn delete(self) -> PixKeyPDelete<'a> {
        PixKeyPDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "PixKeyP".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<PixKeyPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct PixKeyPFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> PixKeyPFindFirst<'a> {
    pub async fn exec(self) -> PixKeyPData {
        self.query.perform().await
    }
    pub fn with(mut self, fetches: Vec<PixKeyPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct PixKeyPFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> PixKeyPFindUnique<'a> {
    pub async fn exec(self) -> PixKeyPData {
        self.query.perform().await
    }
    pub fn delete(self) -> PixKeyPDelete<'a> {
        PixKeyPDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "PixKeyP".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<PixKeyPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct PixKeyPCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> PixKeyPCreateOne<'a> {
    pub async fn exec(self) -> PixKeyPData {
        self.query.perform().await
    }
}
pub struct PixKeyPDelete<'a> {
    query: Query<'a>,
}
impl<'a> PixKeyPDelete<'a> {
    pub async fn exec(self) -> isize {
        let result: DeleteResult = self.query.perform().await;
        result.count
    }
}
impl<'a> PixKeyPActions<'a> {
    pub fn find_unique(&self, param: PixKeyPWhereParam) -> PixKeyPFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "PixKeyP".into(),
            outputs: pix_key_p_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        PixKeyPFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<PixKeyPWhereParam>) -> PixKeyPFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "PixKeyP".into(),
            outputs: pix_key_p_outputs(),
            inputs,
        };
        PixKeyPFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<PixKeyPWhereParam>) -> PixKeyPFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "PixKeyP".into(),
            outputs: pix_key_p_outputs(),
            inputs,
        };
        PixKeyPFindMany { query }
    }
    pub fn create_one(
        &self,
        kind: PixKeyPSetKind,
        key: PixKeyPSetKey,
        created_at: PixKeyPSetCreatedAt,
        account: PixKeyPSetAccount,
        status: PixKeyPSetStatus,
        params: Vec<PixKeyPSetParam>,
    ) -> PixKeyPCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(PixKeyPSetParam::from(kind).field());
        input_fields.push(PixKeyPSetParam::from(key).field());
        input_fields.push(PixKeyPSetParam::from(created_at).field());
        input_fields.push(PixKeyPSetParam::from(account).field());
        input_fields.push(PixKeyPSetParam::from(status).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "PixKeyP".into(),
            outputs: pix_key_p_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        PixKeyPCreateOne { query }
    }
}
fn transaction_p_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("accountPId"),
        Output::new("accountFromId"),
        Output::new("amount"),
        Output::new("pixKeyPId"),
        Output::new("pixKeyIdTo"),
        Output::new("status"),
        Output::new("description"),
        Output::new("cancelDescription"),
        Output::new("createdAt"),
        Output::new("updatedAt"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TransactionPData {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "accountFrom")]
    account_from: Option<AccountPData>,
    #[serde(rename = "accountPId")]
    pub account_p_id: String,
    #[serde(rename = "accountFromId")]
    pub account_from_id: String,
    #[serde(rename = "amount")]
    pub amount: f32,
    #[serde(rename = "pixKeyTo")]
    pix_key_to: Option<PixKeyPData>,
    #[serde(rename = "pixKeyPId")]
    pub pix_key_p_id: String,
    #[serde(rename = "pixKeyIdTo")]
    pub pix_key_id_to: String,
    #[serde(rename = "status")]
    pub status: String,
    #[serde(rename = "description")]
    pub description: String,
    #[serde(rename = "cancelDescription")]
    pub cancel_description: Option<String>,
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[serde(rename = "updatedAt")]
    pub updated_at: Option<String>,
}
impl TransactionPData {
    pub fn account_from(&self) -> Result<&AccountPData, String> {
        match &self.account_from {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access account_from but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
    pub fn pix_key_to(&self) -> Result<&PixKeyPData, String> {
        match &self.pix_key_to {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access pix_key_to but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct TransactionP {}
impl TransactionP {
    pub fn id() -> TransactionPIdField {
        TransactionPIdField {}
    }
    pub fn account_from() -> TransactionPAccountFromField {
        TransactionPAccountFromField {}
    }
    pub fn account_p_id() -> TransactionPAccountPIdField {
        TransactionPAccountPIdField {}
    }
    pub fn account_from_id() -> TransactionPAccountFromIdField {
        TransactionPAccountFromIdField {}
    }
    pub fn amount() -> TransactionPAmountField {
        TransactionPAmountField {}
    }
    pub fn pix_key_to() -> TransactionPPixKeyToField {
        TransactionPPixKeyToField {}
    }
    pub fn pix_key_p_id() -> TransactionPPixKeyPIdField {
        TransactionPPixKeyPIdField {}
    }
    pub fn pix_key_id_to() -> TransactionPPixKeyIdToField {
        TransactionPPixKeyIdToField {}
    }
    pub fn status() -> TransactionPStatusField {
        TransactionPStatusField {}
    }
    pub fn description() -> TransactionPDescriptionField {
        TransactionPDescriptionField {}
    }
    pub fn cancel_description() -> TransactionPCancelDescriptionField {
        TransactionPCancelDescriptionField {}
    }
    pub fn created_at() -> TransactionPCreatedAtField {
        TransactionPCreatedAtField {}
    }
    pub fn updated_at() -> TransactionPUpdatedAtField {
        TransactionPUpdatedAtField {}
    }
    pub fn not(params: Vec<TransactionPWhereParam>) -> TransactionPWhereParam {
        TransactionPWhereParam::Not(params)
    }
    pub fn or(params: Vec<TransactionPWhereParam>) -> TransactionPWhereParam {
        TransactionPWhereParam::Or(params)
    }
    pub fn and(params: Vec<TransactionPWhereParam>) -> TransactionPWhereParam {
        TransactionPWhereParam::And(params)
    }
}
pub struct TransactionPIdField {}
pub struct TransactionPSetId(String);
impl From<TransactionPSetId> for TransactionPSetParam {
    fn from(value: TransactionPSetId) -> Self {
        Self::Id(value.0)
    }
}
impl TransactionPIdField {
    pub fn contains(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::IdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::IdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::IdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::IdEquals(value)
    }
    pub fn set<T: From<TransactionPSetId>>(&self, value: String) -> T {
        TransactionPSetId(value).into()
    }
}
pub struct TransactionPAccountFromField {}
pub struct TransactionPSetAccountFrom(AccountPWhereParam);
impl From<TransactionPSetAccountFrom> for TransactionPSetParam {
    fn from(value: TransactionPSetAccountFrom) -> Self {
        Self::AccountFrom(value.0)
    }
}
impl TransactionPAccountFromField {
    pub fn is(&self, value: Vec<AccountPWhereParam>) -> TransactionPWhereParam {
        TransactionPWhereParam::AccountFromIs(value)
    }
    pub fn link<T: From<TransactionPSetAccountFrom>>(&self, value: AccountPWhereParam) -> T {
        TransactionPSetAccountFrom(value).into()
    }
    pub fn fetch(&self) -> TransactionPWith {
        TransactionPWithParam::AccountFrom.into()
    }
}
pub struct TransactionPAccountPIdField {}
pub struct TransactionPSetAccountPId(String);
impl From<TransactionPSetAccountPId> for TransactionPSetParam {
    fn from(value: TransactionPSetAccountPId) -> Self {
        Self::AccountPId(value.0)
    }
}
impl TransactionPAccountPIdField {
    pub fn contains(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::AccountPIdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::AccountPIdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::AccountPIdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::AccountPIdEquals(value)
    }
    pub fn set<T: From<TransactionPSetAccountPId>>(&self, value: String) -> T {
        TransactionPSetAccountPId(value).into()
    }
}
pub struct TransactionPAccountFromIdField {}
pub struct TransactionPSetAccountFromId(String);
impl From<TransactionPSetAccountFromId> for TransactionPSetParam {
    fn from(value: TransactionPSetAccountFromId) -> Self {
        Self::AccountFromId(value.0)
    }
}
impl TransactionPAccountFromIdField {
    pub fn contains(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::AccountFromIdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::AccountFromIdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::AccountFromIdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::AccountFromIdEquals(value)
    }
    pub fn set<T: From<TransactionPSetAccountFromId>>(&self, value: String) -> T {
        TransactionPSetAccountFromId(value).into()
    }
}
pub struct TransactionPAmountField {}
pub struct TransactionPSetAmount(f32);
impl From<TransactionPSetAmount> for TransactionPSetParam {
    fn from(value: TransactionPSetAmount) -> Self {
        Self::Amount(value.0)
    }
}
impl TransactionPAmountField {
    pub fn lt(&self, value: f32) -> TransactionPWhereParam {
        TransactionPWhereParam::AmountLT(value)
    }
    pub fn gt(&self, value: f32) -> TransactionPWhereParam {
        TransactionPWhereParam::AmountGT(value)
    }
    pub fn lte(&self, value: f32) -> TransactionPWhereParam {
        TransactionPWhereParam::AmountLTE(value)
    }
    pub fn gte(&self, value: f32) -> TransactionPWhereParam {
        TransactionPWhereParam::AmountGTE(value)
    }
    pub fn equals(&self, value: f32) -> TransactionPWhereParam {
        TransactionPWhereParam::AmountEquals(value)
    }
    pub fn set<T: From<TransactionPSetAmount>>(&self, value: f32) -> T {
        TransactionPSetAmount(value).into()
    }
}
pub struct TransactionPPixKeyToField {}
pub struct TransactionPSetPixKeyTo(PixKeyPWhereParam);
impl From<TransactionPSetPixKeyTo> for TransactionPSetParam {
    fn from(value: TransactionPSetPixKeyTo) -> Self {
        Self::PixKeyTo(value.0)
    }
}
impl TransactionPPixKeyToField {
    pub fn is(&self, value: Vec<PixKeyPWhereParam>) -> TransactionPWhereParam {
        TransactionPWhereParam::PixKeyToIs(value)
    }
    pub fn link<T: From<TransactionPSetPixKeyTo>>(&self, value: PixKeyPWhereParam) -> T {
        TransactionPSetPixKeyTo(value).into()
    }
    pub fn fetch(&self) -> TransactionPWith {
        TransactionPWithParam::PixKeyTo.into()
    }
}
pub struct TransactionPPixKeyPIdField {}
pub struct TransactionPSetPixKeyPId(String);
impl From<TransactionPSetPixKeyPId> for TransactionPSetParam {
    fn from(value: TransactionPSetPixKeyPId) -> Self {
        Self::PixKeyPId(value.0)
    }
}
impl TransactionPPixKeyPIdField {
    pub fn contains(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::PixKeyPIdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::PixKeyPIdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::PixKeyPIdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::PixKeyPIdEquals(value)
    }
    pub fn set<T: From<TransactionPSetPixKeyPId>>(&self, value: String) -> T {
        TransactionPSetPixKeyPId(value).into()
    }
}
pub struct TransactionPPixKeyIdToField {}
pub struct TransactionPSetPixKeyIdTo(String);
impl From<TransactionPSetPixKeyIdTo> for TransactionPSetParam {
    fn from(value: TransactionPSetPixKeyIdTo) -> Self {
        Self::PixKeyIdTo(value.0)
    }
}
impl TransactionPPixKeyIdToField {
    pub fn contains(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::PixKeyIdToContains(value)
    }
    pub fn has_prefix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::PixKeyIdToHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::PixKeyIdToHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::PixKeyIdToEquals(value)
    }
    pub fn set<T: From<TransactionPSetPixKeyIdTo>>(&self, value: String) -> T {
        TransactionPSetPixKeyIdTo(value).into()
    }
}
pub struct TransactionPStatusField {}
pub struct TransactionPSetStatus(String);
impl From<TransactionPSetStatus> for TransactionPSetParam {
    fn from(value: TransactionPSetStatus) -> Self {
        Self::Status(value.0)
    }
}
impl TransactionPStatusField {
    pub fn contains(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::StatusContains(value)
    }
    pub fn has_prefix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::StatusHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::StatusHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::StatusEquals(value)
    }
    pub fn set<T: From<TransactionPSetStatus>>(&self, value: String) -> T {
        TransactionPSetStatus(value).into()
    }
}
pub struct TransactionPDescriptionField {}
pub struct TransactionPSetDescription(String);
impl From<TransactionPSetDescription> for TransactionPSetParam {
    fn from(value: TransactionPSetDescription) -> Self {
        Self::Description(value.0)
    }
}
impl TransactionPDescriptionField {
    pub fn contains(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::DescriptionContains(value)
    }
    pub fn has_prefix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::DescriptionHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::DescriptionHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::DescriptionEquals(value)
    }
    pub fn set<T: From<TransactionPSetDescription>>(&self, value: String) -> T {
        TransactionPSetDescription(value).into()
    }
}
pub struct TransactionPCancelDescriptionField {}
pub struct TransactionPSetCancelDescription(String);
impl From<TransactionPSetCancelDescription> for TransactionPSetParam {
    fn from(value: TransactionPSetCancelDescription) -> Self {
        Self::CancelDescription(value.0)
    }
}
impl TransactionPCancelDescriptionField {
    pub fn contains(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::CancelDescriptionContains(value)
    }
    pub fn has_prefix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::CancelDescriptionHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::CancelDescriptionHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::CancelDescriptionEquals(value)
    }
    pub fn set<T: From<TransactionPSetCancelDescription>>(&self, value: String) -> T {
        TransactionPSetCancelDescription(value).into()
    }
}
pub struct TransactionPCreatedAtField {}
pub struct TransactionPSetCreatedAt(String);
impl From<TransactionPSetCreatedAt> for TransactionPSetParam {
    fn from(value: TransactionPSetCreatedAt) -> Self {
        Self::CreatedAt(value.0)
    }
}
impl TransactionPCreatedAtField {
    pub fn contains(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::CreatedAtContains(value)
    }
    pub fn has_prefix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::CreatedAtHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::CreatedAtHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::CreatedAtEquals(value)
    }
    pub fn set<T: From<TransactionPSetCreatedAt>>(&self, value: String) -> T {
        TransactionPSetCreatedAt(value).into()
    }
}
pub struct TransactionPUpdatedAtField {}
pub struct TransactionPSetUpdatedAt(String);
impl From<TransactionPSetUpdatedAt> for TransactionPSetParam {
    fn from(value: TransactionPSetUpdatedAt) -> Self {
        Self::UpdatedAt(value.0)
    }
}
impl TransactionPUpdatedAtField {
    pub fn contains(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::UpdatedAtContains(value)
    }
    pub fn has_prefix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::UpdatedAtHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::UpdatedAtHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> TransactionPWhereParam {
        TransactionPWhereParam::UpdatedAtEquals(value)
    }
    pub fn set<T: From<TransactionPSetUpdatedAt>>(&self, value: String) -> T {
        TransactionPSetUpdatedAt(value).into()
    }
}
pub struct TransactionPActions<'a> {
    client: &'a PrismaClient,
}
pub enum TransactionPWhereParam {
    IdContains(String),
    IdHasPrefix(String),
    IdHasSuffix(String),
    IdEquals(String),
    AccountFromIs(Vec<AccountPWhereParam>),
    AccountPIdContains(String),
    AccountPIdHasPrefix(String),
    AccountPIdHasSuffix(String),
    AccountPIdEquals(String),
    AccountFromIdContains(String),
    AccountFromIdHasPrefix(String),
    AccountFromIdHasSuffix(String),
    AccountFromIdEquals(String),
    AmountLT(f32),
    AmountGT(f32),
    AmountLTE(f32),
    AmountGTE(f32),
    AmountEquals(f32),
    PixKeyToIs(Vec<PixKeyPWhereParam>),
    PixKeyPIdContains(String),
    PixKeyPIdHasPrefix(String),
    PixKeyPIdHasSuffix(String),
    PixKeyPIdEquals(String),
    PixKeyIdToContains(String),
    PixKeyIdToHasPrefix(String),
    PixKeyIdToHasSuffix(String),
    PixKeyIdToEquals(String),
    StatusContains(String),
    StatusHasPrefix(String),
    StatusHasSuffix(String),
    StatusEquals(String),
    DescriptionContains(String),
    DescriptionHasPrefix(String),
    DescriptionHasSuffix(String),
    DescriptionEquals(String),
    CancelDescriptionContains(String),
    CancelDescriptionHasPrefix(String),
    CancelDescriptionHasSuffix(String),
    CancelDescriptionEquals(String),
    CreatedAtContains(String),
    CreatedAtHasPrefix(String),
    CreatedAtHasSuffix(String),
    CreatedAtEquals(String),
    UpdatedAtContains(String),
    UpdatedAtHasPrefix(String),
    UpdatedAtHasSuffix(String),
    UpdatedAtEquals(String),
    Not(Vec<TransactionPWhereParam>),
    Or(Vec<TransactionPWhereParam>),
    And(Vec<TransactionPWhereParam>),
}
impl TransactionPWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdContains(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasPrefix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasSuffix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountFromIs(value) => Field {
                name: "accountFrom".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountPIdContains(value) => Field {
                name: "accountPId".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountPIdHasPrefix(value) => Field {
                name: "accountPId".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountPIdHasSuffix(value) => Field {
                name: "accountPId".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountPIdEquals(value) => Field {
                name: "accountPId".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountFromIdContains(value) => Field {
                name: "accountFromId".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountFromIdHasPrefix(value) => Field {
                name: "accountFromId".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountFromIdHasSuffix(value) => Field {
                name: "accountFromId".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountFromIdEquals(value) => Field {
                name: "accountFromId".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AmountLT(value) => Field {
                name: "amount".into(),
                fields: Some(vec![Field {
                    name: "lt".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AmountGT(value) => Field {
                name: "amount".into(),
                fields: Some(vec![Field {
                    name: "gt".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AmountLTE(value) => Field {
                name: "amount".into(),
                fields: Some(vec![Field {
                    name: "lte".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AmountGTE(value) => Field {
                name: "amount".into(),
                fields: Some(vec![Field {
                    name: "gte".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AmountEquals(value) => Field {
                name: "amount".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeyToIs(value) => Field {
                name: "pixKeyTo".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeyPIdContains(value) => Field {
                name: "pixKeyPId".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeyPIdHasPrefix(value) => Field {
                name: "pixKeyPId".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeyPIdHasSuffix(value) => Field {
                name: "pixKeyPId".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeyPIdEquals(value) => Field {
                name: "pixKeyPId".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeyIdToContains(value) => Field {
                name: "pixKeyIdTo".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeyIdToHasPrefix(value) => Field {
                name: "pixKeyIdTo".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeyIdToHasSuffix(value) => Field {
                name: "pixKeyIdTo".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeyIdToEquals(value) => Field {
                name: "pixKeyIdTo".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusContains(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusHasPrefix(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusHasSuffix(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::StatusEquals(value) => Field {
                name: "status".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DescriptionContains(value) => Field {
                name: "description".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DescriptionHasPrefix(value) => Field {
                name: "description".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DescriptionHasSuffix(value) => Field {
                name: "description".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DescriptionEquals(value) => Field {
                name: "description".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CancelDescriptionContains(value) => Field {
                name: "cancelDescription".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CancelDescriptionHasPrefix(value) => Field {
                name: "cancelDescription".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CancelDescriptionHasSuffix(value) => Field {
                name: "cancelDescription".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CancelDescriptionEquals(value) => Field {
                name: "cancelDescription".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtContains(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtHasPrefix(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtHasSuffix(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CreatedAtEquals(value) => Field {
                name: "createdAt".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtContains(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtHasPrefix(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtHasSuffix(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UpdatedAtEquals(value) => Field {
                name: "updatedAt".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct TransactionPWith {
    pub param: TransactionPWithParam,
}
pub enum TransactionPWithParam {
    AccountFrom,
    PixKeyTo,
}
impl From<TransactionPWithParam> for TransactionPWith {
    fn from(param: TransactionPWithParam) -> Self {
        Self { param }
    }
}
impl TransactionPWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::AccountFrom => Output {
                name: "accountFrom".into(),
                outputs: account_p_outputs(),
                ..Default::default()
            },
            Self::PixKeyTo => Output {
                name: "pixKeyTo".into(),
                outputs: pix_key_p_outputs(),
                ..Default::default()
            },
        }
    }
}
pub enum TransactionPSetParam {
    Id(String),
    AccountFrom(AccountPWhereParam),
    AccountPId(String),
    AccountFromId(String),
    Amount(f32),
    PixKeyTo(PixKeyPWhereParam),
    PixKeyPId(String),
    PixKeyIdTo(String),
    Status(String),
    Description(String),
    CancelDescription(String),
    CreatedAt(String),
    UpdatedAt(String),
}
impl TransactionPSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::AccountFrom(where_param) => Field {
                name: "accountFrom".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::AccountPId(value) => Field {
                name: "accountPId".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::AccountFromId(value) => Field {
                name: "accountFromId".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Amount(value) => Field {
                name: "amount".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::PixKeyTo(where_param) => Field {
                name: "pixKeyTo".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PixKeyPId(value) => Field {
                name: "pixKeyPId".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::PixKeyIdTo(value) => Field {
                name: "pixKeyIdTo".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Status(value) => Field {
                name: "status".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Description(value) => Field {
                name: "description".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::CancelDescription(value) => Field {
                name: "cancelDescription".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::CreatedAt(value) => Field {
                name: "createdAt".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::UpdatedAt(value) => Field {
                name: "updatedAt".into(),
                value: Some(value.into()),
                ..Default::default()
            },
        }
    }
}
pub struct TransactionPFindMany<'a> {
    query: Query<'a>,
}
impl<'a> TransactionPFindMany<'a> {
    pub async fn exec(self) -> Vec<TransactionPData> {
        self.query.perform().await
    }
    pub fn delete(self) -> TransactionPDelete<'a> {
        TransactionPDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "TransactionP".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<TransactionPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TransactionPFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> TransactionPFindFirst<'a> {
    pub async fn exec(self) -> TransactionPData {
        self.query.perform().await
    }
    pub fn with(mut self, fetches: Vec<TransactionPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TransactionPFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> TransactionPFindUnique<'a> {
    pub async fn exec(self) -> TransactionPData {
        self.query.perform().await
    }
    pub fn delete(self) -> TransactionPDelete<'a> {
        TransactionPDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "TransactionP".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<TransactionPWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct TransactionPCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> TransactionPCreateOne<'a> {
    pub async fn exec(self) -> TransactionPData {
        self.query.perform().await
    }
}
pub struct TransactionPDelete<'a> {
    query: Query<'a>,
}
impl<'a> TransactionPDelete<'a> {
    pub async fn exec(self) -> isize {
        let result: DeleteResult = self.query.perform().await;
        result.count
    }
}
impl<'a> TransactionPActions<'a> {
    pub fn find_unique(&self, param: TransactionPWhereParam) -> TransactionPFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "TransactionP".into(),
            outputs: transaction_p_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        TransactionPFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<TransactionPWhereParam>) -> TransactionPFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "TransactionP".into(),
            outputs: transaction_p_outputs(),
            inputs,
        };
        TransactionPFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<TransactionPWhereParam>) -> TransactionPFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "TransactionP".into(),
            outputs: transaction_p_outputs(),
            inputs,
        };
        TransactionPFindMany { query }
    }
    pub fn create_one(
        &self,
        id: TransactionPSetId,
        account_from: TransactionPSetAccountFrom,
        account_from_id: TransactionPSetAccountFromId,
        amount: TransactionPSetAmount,
        pix_key_to: TransactionPSetPixKeyTo,
        pix_key_id_to: TransactionPSetPixKeyIdTo,
        status: TransactionPSetStatus,
        description: TransactionPSetDescription,
        created_at: TransactionPSetCreatedAt,
        params: Vec<TransactionPSetParam>,
    ) -> TransactionPCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(TransactionPSetParam::from(id).field());
        input_fields.push(TransactionPSetParam::from(account_from).field());
        input_fields.push(TransactionPSetParam::from(account_from_id).field());
        input_fields.push(TransactionPSetParam::from(amount).field());
        input_fields.push(TransactionPSetParam::from(pix_key_to).field());
        input_fields.push(TransactionPSetParam::from(pix_key_id_to).field());
        input_fields.push(TransactionPSetParam::from(status).field());
        input_fields.push(TransactionPSetParam::from(description).field());
        input_fields.push(TransactionPSetParam::from(created_at).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "TransactionP".into(),
            outputs: transaction_p_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        TransactionPCreateOne { query }
    }
}

// Code generated by Prisma Client Rust. DO NOT EDIT.

use prisma_client_rust::datamodel::parse_configuration;
use prisma_client_rust::prisma_models::InternalDataModelBuilder;
use prisma_client_rust::query::*;
use prisma_client_rust::query_core::{
    executor, schema_builder, BuildMode, QueryExecutor, QuerySchema,
};
use prisma_client_rust::DeleteResult;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
pub struct PrismaClient {
    executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
    query_schema: Arc<QuerySchema>,
}
impl PrismaClient {
    pub async fn new() -> Self {
        let datamodel_str = "// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider      = \"prisma-client-rust\"\n  binaryTargets = [\"native\"]\n  output        = \"../src/db.rs\"\n}\n\ndatasource db {\n  provider = \"sqlite\"\n  url      = \"file:./dev.db\"\n}\n\nmodel User {\n  id          String @id\n  displayName String\n}\n" ;
        let config = parse_configuration(datamodel_str).unwrap().subject;
        let source = config
            .datasources
            .first()
            .expect("Pleasy supply a datasource in your schema.prisma file");
        let url = if let Some(url) = source.load_shadow_database_url().unwrap() {
            url
        } else {
            source.load_url(|key| std::env::var(key).ok()).unwrap()
        };
        let (db_name, executor) = executor::load(&source, &[], &url).await.unwrap();
        let internal_model = InternalDataModelBuilder::new(&datamodel_str).build(db_name);
        let query_schema = Arc::new(schema_builder::build(
            internal_model,
            BuildMode::Modern,
            true,
            source.capabilities(),
            vec![],
            source.referential_integrity(),
        ));
        executor.primary_connector().get_connection().await.unwrap();
        Self {
            executor,
            query_schema,
        }
    }
    pub fn user(&self) -> UserActions {
        UserActions { client: &self }
    }
}
fn user_outputs() -> Vec<Output> {
    vec![Output::new("id"), Output::new("displayName")]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserData {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "displayName")]
    pub display_name: String,
}
impl UserData {}
pub struct User {}
impl User {
    pub fn id() -> UserIdField {
        UserIdField {}
    }
    pub fn display_name() -> UserDisplayNameField {
        UserDisplayNameField {}
    }
    pub fn not(params: Vec<UserWhereParam>) -> UserWhereParam {
        UserWhereParam::Not(params)
    }
    pub fn or(params: Vec<UserWhereParam>) -> UserWhereParam {
        UserWhereParam::Or(params)
    }
    pub fn and(params: Vec<UserWhereParam>) -> UserWhereParam {
        UserWhereParam::And(params)
    }
}
pub struct UserIdField {}
pub struct UserSetId(String);
impl From<UserSetId> for UserSetParam {
    fn from(value: UserSetId) -> Self {
        Self::Id(value.0)
    }
}
impl UserIdField {
    pub fn contains(&self, value: String) -> UserWhereParam {
        UserWhereParam::IdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> UserWhereParam {
        UserWhereParam::IdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> UserWhereParam {
        UserWhereParam::IdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> UserWhereParam {
        UserWhereParam::IdEquals(value)
    }
    pub fn set<T: From<UserSetId>>(&self, value: String) -> T {
        UserSetId(value).into()
    }
}
pub struct UserDisplayNameField {}
pub struct UserSetDisplayName(String);
impl From<UserSetDisplayName> for UserSetParam {
    fn from(value: UserSetDisplayName) -> Self {
        Self::DisplayName(value.0)
    }
}
impl UserDisplayNameField {
    pub fn contains(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameEquals(value)
    }
    pub fn set<T: From<UserSetDisplayName>>(&self, value: String) -> T {
        UserSetDisplayName(value).into()
    }
}
pub struct UserActions<'a> {
    client: &'a PrismaClient,
}
pub enum UserWhereParam {
    IdContains(String),
    IdHasPrefix(String),
    IdHasSuffix(String),
    IdEquals(String),
    DisplayNameContains(String),
    DisplayNameHasPrefix(String),
    DisplayNameHasSuffix(String),
    DisplayNameEquals(String),
    Not(Vec<UserWhereParam>),
    Or(Vec<UserWhereParam>),
    And(Vec<UserWhereParam>),
}
impl UserWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdContains(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasPrefix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasSuffix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameContains(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameHasPrefix(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameHasSuffix(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameEquals(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct UserWith {
    pub param: UserWithParam,
}
pub enum UserWithParam {}
impl From<UserWithParam> for UserWith {
    fn from(param: UserWithParam) -> Self {
        Self { param }
    }
}
impl UserWithParam {
    pub fn output(self) -> Output {
        match self {}
    }
}
pub enum UserSetParam {
    Id(String),
    DisplayName(String),
}
impl UserSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::DisplayName(value) => Field {
                name: "displayName".into(),
                value: Some(value.into()),
                ..Default::default()
            },
        }
    }
}
pub struct UserFindMany<'a> {
    query: Query<'a>,
}
impl<'a> UserFindMany<'a> {
    pub async fn exec(self) -> Vec<UserData> {
        self.query.perform().await
    }
    pub fn delete(self) -> UserDelete<'a> {
        UserDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "User".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<UserWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct UserFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> UserFindFirst<'a> {
    pub async fn exec(self) -> UserData {
        self.query.perform().await
    }
    pub fn with(mut self, fetches: Vec<UserWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct UserFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> UserFindUnique<'a> {
    pub async fn exec(self) -> UserData {
        self.query.perform().await
    }
    pub fn delete(self) -> UserDelete<'a> {
        UserDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "User".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<UserWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct UserCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> UserCreateOne<'a> {
    pub async fn exec(self) -> UserData {
        self.query.perform().await
    }
}
pub struct UserDelete<'a> {
    query: Query<'a>,
}
impl<'a> UserDelete<'a> {
    pub async fn exec(self) -> isize {
        let result: DeleteResult = self.query.perform().await;
        result.count
    }
}
impl<'a> UserActions<'a> {
    pub fn find_unique(&self, param: UserWhereParam) -> UserFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        UserFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<UserWhereParam>) -> UserFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs,
        };
        UserFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<UserWhereParam>) -> UserFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs,
        };
        UserFindMany { query }
    }
    pub fn create_one(
        &self,
        id: UserSetId,
        display_name: UserSetDisplayName,
        params: Vec<UserSetParam>,
    ) -> UserCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(UserSetParam::from(id).field());
        input_fields.push(UserSetParam::from(display_name).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        UserCreateOne { query }
    }
}
